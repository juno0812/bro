
##! Functions to interface with broker's distributed data store.

%%{
#include "broker/Manager.h"
#include "broker/Store.h"
#include "broker/Data.h"
#include "Trigger.h"
%%}

module Broker;

type Broker::ExpiryTime: record;

type Broker::QueryResult: record;

type Broker::BackendOptions: record;

## Enumerates the possible storage backends.
enum BackendType %{
	MEMORY,
	SQLITE,
	ROCKSDB,
%}

function Broker::__create_master%(id: string, b: BackendType,
                               options: BackendOptions &default = BackendOptions()%): opaque of Broker::Handle
	%{
	auto name = id->CheckString();
	auto rval = broker_mgr->LookupStore(name);
	if ( ! rval )
		return nullptr;

  auto e = static_cast<BifEnum::Broker::BackendType>(b->AsEnum());
	auto type = bro_broker::to_backend_type(e);
	auto opts = bro_broker::to_backend_options(type, options->AsRecordVal());

	auto store = broker_mgr->MakeMaster(name, type, std::move(opts));
	if ( ! store )
	  return nullptr;

	return store;
	%}

function Broker::__create_clone%(id: string%): opaque of Broker::Handle
	%{
	auto name = id->CheckString();
	auto rval = broker_mgr->LookupStore(name);
	if ( ! rval )
		return nullptr;

	auto store = broker_mgr->MakeClone(name);
	if ( ! store )
	  return nullptr;

	return store;
	%}

function Broker::__close_by_handle%(h: opaque of Broker::Handle%): bool
	%{
	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	if ( ! *handle )
    return new Val(false, TYPE_BOOL);

	return new Val(broker_mgr->CloseStore(handle->store.name()), TYPE_BOOL);
	%}

###########################
# non-blocking update API #
###########################

function Broker::__insert%(h: opaque of Broker::Handle,
                        k: Broker::Data, v: Broker::Data,
                        e: Broker::ExpiryTime &default = Broker::ExpiryTime()%): bool
	%{
	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	if ( ! *handle )
    return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(k->AsRecordVal(), frame);
	auto& val = bro_broker::opaque_field_to_data(v->AsRecordVal(), frame);

	if ( auto abs_expiry_val = e->AsRecordVal()->Lookup(0) )
		{
		auto expiry = broker::fractional_seconds{abs_expiry_val->AsTime()};
		auto since_epoch = std::chrono::duration_cast<broker::timespan>(expiry);
		handle->store.put(key, val, broker::timestamp{since_epoch});
		return new Val(true, TYPE_BOOL);
		}

	if ( auto rel_expiry_val = e->AsRecordVal()->Lookup(1) )
		{
		auto now = broker::clock::now();
		auto delta = broker::fractional_seconds{rel_expiry_val->AsInterval()};
		auto expiry = now + std::chrono::duration_cast<broker::timespan>(delta);
		handle->store.put(key, val, expiry);
		return new Val(true, TYPE_BOOL);
		}

	handle->store.put(key, val);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__erase%(h: opaque of Broker::Handle, k: Broker::Data%): bool
	%{
	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	if ( ! *handle )
    return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(k->AsRecordVal(), frame);
	handle->store.erase(key);
	return new Val(true, TYPE_BOOL);
	%}

##########################
# non-blocking query API #
##########################

function Broker::__lookup%(h: opaque of Broker::Handle,
                       k: Broker::Data%): Broker::QueryResult
	%{
	if ( ! broker_mgr->Enabled() )
		return bro_broker::query_result();

	auto key = k->AsRecordVal()->Lookup(0);
	if ( ! key )
		return bro_broker::query_result();

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	if ( ! *handle )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker query has an invalid data store");
		reporter->PopLocation();
    return bro_broker::query_result();
		}

	auto trigger = frame->GetTrigger();
	if ( ! trigger )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries can only be called inside when-condition");
		reporter->PopLocation();
    return bro_broker::query_result();
		}

	auto timeout = trigger->TimeoutValue();
	if ( timeout < 0 )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries must specify a timeout block");
		reporter->PopLocation();
    return bro_broker::query_result();
		}

	frame->SetDelayed();
	trigger->Hold();

	auto cb = new bro_broker::StoreQueryCallback(trigger, frame->GetCall(),
                                               handle->store);
  // TODO: pass timeout to proxy.
	auto req_id = handle->proxy.get(static_cast<bro_broker::DataVal*>(key)->data);
	broker_mgr->TrackStoreQuery(req_id, cb);

	return 0;
	%}
